---
title: "Update Water in Cellar Complaints App"
author: "Farshad Ebrahimi"
date: "`r lubridate::now()`"
output: html_document
params:
    database: "mars_data" 
    write: FALSE #Write changes to database?
---

```{r setup, include=FALSE}

  knitr::opts_chunk$set(echo = TRUE)

  library(DBI)
  library(RPostgreSQL)
  library(RPostgres)
  library(odbc)
  library(RODBC)
  library(dplyr)
  library(tidyr)
  library(sf)
  library(shiny)
  library(lubridate)
  library(knitr)

  MARSDB_con <- dbConnect(odbc(), dsn = params$database)
  cityworksDB_con <- dbConnect(odbc(),
                  Driver = "ODBC Driver 17 for SQL Server",
                  Server = "PWDCWSQLT",
                  Database = "PWD_Cityworks",
                  uid = Sys.getenv("cw_uid"),
                  pwd= Sys.getenv("cw_pwd"))
  GISDB_con <- dbConnect(odbc(),
                  Driver = "ODBC Driver 17 for SQL Server",
                  Server = "PWDGISSQL",
                  Database = "GISDATA",
                  uid = Sys.getenv("gis_uid"),
                  pwd= Sys.getenv("gis_pwd"))
  
  dsn_infra_pub <- paste0("MSSQL:server=PWDGISSQL;",
                              "database=INFRASTRUCTURE_PUBLIC;",
                              "UID=gisread;",
                              "PWD=gisread;")
   
  wic_parcels <- data.frame(matrix(NA, 0, 2)) #place holders (equivalent for 0-rows)
  output_25 <- data.frame(matrix(NA, 0, 2))
  output_50 <- data.frame(matrix(NA, 0, 2))
  output_100 <- data.frame(matrix(NA, 0, 2))

      
  
```


```{r Section 1 - Checking for new WIC complaints, new WIC comments, and any other changes, include=FALSE}
    
# gather wic orders and comments from citywork 

   cityworks_workorders <- dbGetQuery(cityworksDB_con, "SELECT wo.WORKORDERID, wo.INITIATEDATE AS WO_INITIATEDATE, wo.LOCATION, wo.WOXCOORDINATE, 
    wo.WOYCOORDINATE, woe.ENTITYUID AS FACILITYID FROM Azteca.WORKORDER wo INNER JOIN 
    Azteca.REQUESTWORKORDER rwo ON wo.WORKORDERID = rwo.WORKORDERID LEFT JOIN 
    Azteca.REQUEST r ON rwo.REQUESTID = r.REQUESTID LEFT JOIN Azteca.WORKORDERENTITY woe ON 
    wo.WORKORDERID = woe.WORKORDERID WHERE 
    ((wo.DESCRIPTION = 'A - PROPERTY INVESTIGATION' AND r.DESCRIPTION = 'WATER IN CELLAR') OR 
    (wo.DESCRIPTION = 'A - LEAK INVESTIGATION' AND r.DESCRIPTION = 'WATER IN CELLAR'))
    ")
   cityworks_cm <- dbGetQuery(cityworksDB_con, "SELECT WORKORDERID, COMMENTS from Azteca.WOCOMMENT" )
   
# gather current wic orders and comments from MARS_Data
   
   wic_workorders <- dbGetQuery(MARSDB_con, "SELECT * FROM fieldwork.wic_workorders ")
   wic_comments <- dbGetQuery(MARSDB_con, "SELECT * FROM fieldwork.wic_comments ")
   
# change the data column format; for some reason anti_join cannot match the dates in POSIXct
   
   wic_workorders$wo_initiatedate <- as.Date(wic_workorders$wo_initiatedate)
   cityworks_workorders$WO_INITIATEDATE <- as.Date(cityworks_workorders$WO_INITIATEDATE)
   
   cityworks_workorders$WORKORDERID <- as.numeric(cityworks_workorders$WORKORDERID)
   cityworks_cm$WORKORDERID <- as.numeric(cityworks_cm$WORKORDERID)
   
# make names consistent    

   names(cityworks_workorders) <- c("workorder_id","wo_initiatedate","location","wo_xcoordinate","wo_ycoordinate","facility_id")
   names (cityworks_cm) <- c("workorder_id","comments")
   
# find the new wic complaint and changed ones in cityworks DB
   
   new_wic <- cityworks_workorders %>% filter(!(workorder_id %in% wic_workorders$workorder_id))
   cityworks_workorders_old <- anti_join(cityworks_workorders, new_wic, by = "workorder_id")
   changed_wic_cityworks <- cityworks_workorders_old  %>%
     anti_join(wic_workorders, by = c("workorder_id","wo_initiatedate","location","wo_xcoordinate","wo_ycoordinate","facility_id")) 
   wo_noparcels <- bind_rows(changed_wic_cityworks, new_wic)

   
# Append the new WIC to wic_workorders
   
   if( nrow(new_wic) > 0 & params$write == TRUE ){
  
  dbWriteTable (MARSDB_con, SQL("fieldwork.wic_workorders"),new_wic,append= TRUE, row.names = FALSE)
     
  }
   
# Update the workorders in wic_workorders that have been changed in cityworks DB 
   
   if(nrow(changed_wic_cityworks) > 0 & params$write == TRUE){
     
     sql_string <- "UPDATE fieldwork.wic_workorders SET wo_initiatedate = '%s', location = '%s',  wo_xcoordinate = %s,wo_ycoordinate= %s,facility_id = '%s' WHERE workorder_id = %s;"
     dbSendStatement(MARSDB_con, paste(sprintf(sql_string, changed_wic_cityworks$wo_initiatedate, changed_wic_cityworks$location,changed_wic_cityworks$wo_xcoordinate,changed_wic_cityworks$wo_ycoordinate,changed_wic_cityworks$facility_id,changed_wic_cityworks$workorder_id), collapse=""))
     
   }
   
# update comments and add new comments to the new workorders
   
   workorders_unique <- select(cityworks_workorders,workorder_id) %>% unique()
   cw_wic_comments <- inner_join(workorders_unique, cityworks_cm, by = "workorder_id")
   cw_wic_comments<- cw_wic_comments %>%
       group_by(workorder_id) %>%
       summarise(comments = toString(sort(unique(comments)))) 
   new_wo_comments <- inner_join(new_wic, cw_wic_comments, by = "workorder_id") %>% select(workorder_id, comments)
   old_wo_comments <-anti_join(cw_wic_comments, new_wo_comments, by = "workorder_id")
   old_wo_comments <-as.data.frame(old_wo_comments)
   
   old_wo_comments$comments <- gsub("[\r\n]", "", old_wo_comments$comments)
   wic_comments$comments <- gsub("[\r\n]", "", wic_comments$comments)

   changed_comments <- anti_join(old_wo_comments, wic_comments, by = c("comments"))
   changed_comments_cityworks <- changed_comments %>% select(workorder_id) %>% inner_join(cw_wic_comments, by = "workorder_id")
   

   
    if( nrow(new_wo_comments) > 0 & params$write == TRUE ){
      
  dbWriteTable (MARSDB_con, SQL("fieldwork.wic_comments"),new_wo_comments,append= TRUE, row.names = FALSE)
      
    }
   
   
   if(nrow(changed_comments_cityworks) > 0 & params$write == TRUE){
     
     sql_string <- "UPDATE fieldwork.wic_comments SET comments = '%s' WHERE workorder_id = %s;"
     dbSendStatement(MARSDB_con, paste(sprintf(sql_string, changed_comments_cityworks$comments, changed_comments_cityworks$workorder_id), collapse=""))
     
   }
   
```
 The cityworks database has been examined for new water-in-cellar work orders, and also any changes that have been made to the existing work orders. There are `r nrow(new_wic)` new work orders and `r nrow(changed_wic_cityworks)` work orders whose fields have changed. There are also `r nrow(changed_comments_cityworks)` work orders whose comments have been modified.  
 
```{r Section 2- displaying tables of new work orders and changed work orders ,echo=FALSE, results='asis'}

  if (nrow(new_wic) > 0) {

    kable(new_wic, caption = "New Work Orders in Cityworks Database")
    
  }

  if (nrow(changed_wic_cityworks) > 0) {

    kable(nrow(changed_wic_cityworks), caption = "Modified Work Orders in Cityworks Database")
    
  }

```

```{r Section 3- attach parcels to new and changed workorder based on facility id ,include=FALSE, eval= nrow(wo_noparcels) > 0}
    
     Parcels_Frame <- dbGetQuery(GISDB_con, "SELECT * from GISDATA.GISAD.PWD_PARCELS")
     Parcels_facility_id <- select(Parcels_Frame, FACILITYID)
     Parcels_Address_id <- select(Parcels_Frame, ADDRESS, FACILITYID)
     PARCELS_SPATIAL <- st_read(dsn = "\\\\pwdoows\\oows\\Watershed Sciences\\GSI Monitoring\\09 GIS Data\\PWD_PARCELS ", layer = "PWD_PARCELS")
     st_crs(PARCELS_SPATIAL) = 2272
     wo_noparcels$facility_id<-gsub("\\{(.*)\\}","\\1",as.character(wo_noparcels$facility_id))
  



    ##Matching by facility ID
     
    # Inner join the wo_noparcels and Parcels_Addressid ON facility ID
      WOID_FACID_Match <- inner_join (wo_noparcels, Parcels_Address_id  , by = c("facility_id"="FACILITYID"))
    # Get FIRST OUTPUT BASED ON FACILITYID MATCH STORED IN WOID_FAC_UNIQ_REL
      WOID_FAC_UNIQ_REL <- select(WOID_FACID_Match, workorder_id, location, facility_id)
    # Remove the rows that we matched based on the facilityid from the cityworks table 
      wo_noparcels <- anti_join(wo_noparcels, WOID_FACID_Match, by = "workorder_id")
    # Remove the rows that were matched from the Parcels_Address_id table
      Parcels_Address_id <-anti_join(Parcels_Address_id, WOID_FACID_Match, by = c("FACILITYID"="facility_id") )
    # drop the facility id from workorderid as these ids are not meaningful 
      WORKORDER_ID_Location<-  select(wo_noparcels, -facility_id)
      
      wic_parcel_attach <- WOID_FAC_UNIQ_REL
      
```


```{r Section 4- attach parcels to new and changed workorder based on address ,include=FALSE, eval= nrow(wo_noparcels) > 0}
   
    ##Matching by address
      
    # Inner join the  WORKORDER_ID_Location with Parcels_Address_id to extract the facility id
      WO_ID_ADDRESS_MATCH <- inner_join(WORKORDER_ID_Location,Parcels_Address_id,by = c("location" = "ADDRESS"))
    # GET SECOND OUTPUT BASED ON FACILITYID MATCH STORED IN WOID_FAC_UNIQ_Add_REL )  
      WOID_FAC_UNIQ_Add_REL <- WO_ID_ADDRESS_MATCH  %>% select(workorder_id, location, facility_id = FACILITYID)  
    # Remove the rows that we were matched based on the address from the cityworkstable 
      wo_noparcels <- anti_join(wo_noparcels, WO_ID_ADDRESS_MATCH, by = "workorder_id")
    # Remove the rows that were matched from the Parcels_Address_id table
      Parcels_Address_id <-anti_join(Parcels_Address_id, WO_ID_ADDRESS_MATCH, by = "FACILITYID" ) 
      
    # stick previous results together
      wic_parcel_attach <- union_all (wic_parcel_attach, WOID_FAC_UNIQ_Add_REL)

```

```{r Section 5- attach parcels to new and changed workorder based on XY coordinate ,include=FALSE, eval= nrow(wo_noparcels) > 0}

    
   ##Matching by XY coordinates
      
    # Build the spatial object from the XY coordinates in Cityworks
     
      xy_coor <-  c(wo_noparcels[,"wo_xcoordinate"],wo_noparcels[,"wo_ycoordinate"])
      mat_coor <- matrix(data = xy_coor, ncol = 2) %>% na.omit
      WO_SPATIAL <- mat_coor |> 
         as.matrix() |> 
         st_multipoint() |> 
         st_sfc() |> 
         st_cast('POINT')
      st_crs(WO_SPATIAL) <- 2272
      
    # Intersect the Parcel polygons and the points
       WO_PARC_INTERSECT <- st_intersects(WO_SPATIAL, PARCELS_SPATIAL )
   
    # Get the index of intersecting XY coordinates and Parcel polygons
       
       Index_WO <- NULL
       Index_Parcel <- NULL
        for(i in 1:length(WO_PARC_INTERSECT)) {
            temp <- WO_PARC_INTERSECT[[i]]
              if (length(temp) > 0) {
              WO <- rep(i, length(temp))
              Parcel <- temp
              Index_WO <- c(Index_WO, WO )
              Index_Parcel <- c(Index_Parcel, Parcel ) 
              }
         }
      
    # attach the XY coordinate to the Parcel frame to create COORD_MATCHED_TABLE
       
       mat_coor <- data.frame (mat_coor)
       names(mat_coor) <- c("wo_xcoordinate","wo_ycoordinate")
       WO_MATCHED_XY <- mat_coor[Index_WO, ]
       Parcel_Matched_Polyg <- Parcels_Frame[Index_Parcel, ]
       COORD_MATCHED_TABLE <- cbind(Parcel_Matched_Polyg,WO_MATCHED_XY)
       
    # Get workorderid, address, and facilityid (Third output is stored in WOID_Based_XY )
       
       WOID_Based_XY<- wo_noparcels %>% select(workorder_id, wo_initiatedate, location, wo_xcoordinate, wo_ycoordinate) %>% inner_join(COORD_MATCHED_TABLE, by = c("wo_xcoordinate" = "wo_xcoordinate", "wo_ycoordinate" = "wo_ycoordinate")) %>% select(workorder_id, location = ADDRESS, facility_id = FACILITYID) 
       
       wic_parcel_attach <- union_all (wic_parcel_attach, WOID_Based_XY)

       
```


The new and modified work orders (total = `r nrow(bind_rows(changed_wic_cityworks, new_wic))` ) were searched in GIS database by their facility id, location, and XY coordinate. This has resulted in `r nrow(wic_parcel_attach)` parcel attachment.  

```{r Section 5- write to DB ,include=FALSE}

       
    # union the matching tables-Final output is in FACID_ADD_XY
     
       wic_parcels <- unique(wic_parcel_attach)
       
    # Add the workorder date 
       
       WORKORDER_ID <- bind_rows(changed_wic_cityworks, new_wic)
       WORK_DATE <- WORKORDER_ID %>% select(workorder_id, wo_initiatedate)
       wic_parcels <- inner_join(wic_parcels, WORK_DATE, by = "workorder_id") %>% select(workorder_id, location, facility_id, wo_initiatedate)
       
     
    ## write to database
     
      if( nrow(wic_parcels) > 0 & params$write == TRUE ){
      
        dbWriteTable (MARSDB_con, SQL("fieldwork.wic_parcels"),wic_parcels,append= TRUE, row.names = FALSE)
      
      }

```



```{r Section 6- displaying tables of parcels attached to the new and changed work orders and write to DB ,echo=FALSE, results='asis'}

     if ( nrow(wic_parcels) > 0 ) {
    
        kable(wic_parcels, caption = "Parcel attachment for new/changed workorders")
    
      }

      if ( nrow(wic_parcels) > 0 & params$write == TRUE){
    
        dbWriteTable (MARSDB_con, SQL("fieldwork.wic_parcels"),wic_parcels,append= TRUE, row.names = FALSE)

      }

```


```{r Section 7- SMP intersect, include=FALSE, eval= nrow(wic_parcels) > 0 }

      basin <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIBASIN", quiet = TRUE)) 
      blueroof <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIBLUEROOF", quiet = TRUE)) 
      bumpout <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIBUMPOUT", quiet = TRUE)) 
      cistern <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWICISTERN", quiet = TRUE)) 
      
  # something wrong with drainagewell 
      
      #drainagewell <- suppressWarnings(st_read(dsn_infra_pub, "GISAD.gswiDrainageWell", quiet = TRUE))
      
      greenroof <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIGREENROOF", quiet = TRUE))
      permeablepavement <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIPERMEABLEPAVEMENT", quiet = TRUE))
      planter <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIPLANTER", quiet = TRUE))
      raingarden <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIRAINGARDEN", quiet = TRUE))
      swale <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWISWALE", quiet = TRUE))
      treetrench <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWITREETRENCH", quiet = TRUE))
      trench <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWITRENCH", quiet = TRUE)) 
      wetland <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIWETLAND", quiet = TRUE))
      st_crs ( basin) <- 2272 
      st_crs (blueroof) <- 2272
      st_crs(bumpout) <- 2272
      st_crs(cistern) <- 2272
        
  # something wrong with drainagewell 
      
      #st_crs (drainagewell) <- 2272
      st_crs (greenroof) <- 2272
      st_crs (permeablepavement) <- 2272
      st_crs (planter) <- 2272
      st_crs(raingarden) <- 2272
      st_crs (swale) <- 2272
      st_crs(treetrench) <- 2272
      st_crs(trench) <- 2272
      st_crs (wetland) <- 2272
  
      
  # filter to get WIC associated polygons and delete the layer
      
      WIC_ID_TABLE <- wic_parcels
      PARCELS_SPATIAL$FACILITYID<-gsub("\\{(.*)\\}","\\1",as.character(PARCELS_SPATIAL$FACILITYID))
      Parcels_WIC_Filterd <- inner_join(PARCELS_SPATIAL, WIC_ID_TABLE, by = c("FACILITYID"="facility_id") )
      rm(PARCELS_SPATIAL)
      Parcels_filtered_df <-as.data.frame(Parcels_WIC_Filterd)
      Parcels_filtered_df$wo_initiatedate <- as.Date(Parcels_filtered_df$wo_initiatedate)
      
  # Drop columns except the SMP_ID and Merge all SMPs
      
      basin <- basin %>% select(SMP_ID)
      blueroof<- blueroof %>% select(SMP_ID)
      bumpout <- bumpout %>% select(SMP_ID)
      cistern <- cistern %>% select(SMP_ID)
      #drainagewell <- drainagewell %>% select(SMP_ID)
      greenroof<- greenroof %>% select(SMP_ID)
      permeablepavement <- permeablepavement %>% select(SMP_ID)
      planter<- planter %>% select(SMP_ID)
      raingarden <- raingarden %>% select(SMP_ID)
      swale <- swale %>% select(SMP_ID)
      treetrench <- treetrench %>% select(SMP_ID)
      trench<- trench %>% select(SMP_ID)
      wetland <- wetland %>% select(SMP_ID)

  # something wrong with drainagewell 
      
     # SMP <- bind_rows(basin, blueroof, bumpout, cistern, drainagewell, greenroof, permeablepavement, planter, raingarden, swale, treetrench, trench, wetland)
      SMP <- bind_rows(basin, blueroof, bumpout, cistern, greenroof, permeablepavement, planter, raingarden, swale, treetrench, trench, wetland)
      
  # filter SMPs to non-private ones
      Boolean <- grepl ("\\d+-\\d+-\\d+", SMP[["SMP_ID"]])
      SMPID_IND <- which(as.numeric(Boolean)!=0, T)
      SMP <- SMP[SMPID_IND, ]
      
## Section 2: Create buffers (25, 50, and 100 ft) around SMPs and intersect them with the WIC Parcels
      
  #set 25, 50, 100 ft buffer around the SMPs
      
      SMP_buffer_25 <- st_buffer(SMP, 25)
      SMP_buffer_50 <- st_buffer(SMP, 50)
      SMP_buffer_100 <- st_buffer(SMP, 100)
    
  #INTERSECT the WIC with buffered SMPs
      
      SMP_inters_25 <- st_intersects(SMP_buffer_25, Parcels_WIC_Filterd)
      SMP_inters_50 <- st_intersects(SMP_buffer_50, Parcels_WIC_Filterd)
      SMP_inters_100 <- st_intersects(SMP_buffer_100, Parcels_WIC_Filterd)
      
## Section 3: Extract the intersecting SMP-PARCEL and populate the result dataframe 
      
  # create a conditional loop, that loops through each element of the list column of intersect (sparse matrix) , gets the indexes of the 
  # WIC_parcels, and populates a data frame, consisting the SMP_ID, FACILITYID of the wic -parcel, and the size of buffer
      
  # buffer 25 ft

      Inters_Obj <- SMP_inters_25
      GSI <- as.data.frame(SMP)
      Buffer <- 25
      output <- NULL
      df <- NULL
      
      for(i in 1:length(Inters_Obj)) {
        
      temp <- Inters_Obj[[i]]
       
        if (length(temp) > 0) {
        FACI_ID <- Parcels_filtered_df[temp, "FACILITYID"]
        WO_ID <- Parcels_filtered_df[temp, "workorder_id"]
        WO_Date <- Parcels_filtered_df[temp, "wo_initiatedate"]
        SMPID <- GSI [i,"SMP_ID"]
        SMPID_Vec <- rep(SMPID, length(temp))
        Buffer_Vec <-  rep(Buffer, length(temp))
        df <- data.frame(SMPID_Vec, FACI_ID, Buffer_Vec, WO_ID, WO_Date)
        output <- rbind(output, df ) 
        }
      
      output_25 <-output
       
      } 
      
  # buffer 50 ft 
      
      Inters_Obj <- SMP_inters_50
      GSI <- as.data.frame(SMP)
      Buffer <- 50
      output <- NULL
      df <- NULL
      for(i in 1:length(Inters_Obj)) {
      temp <- Inters_Obj[[i]]
        if (length(temp) > 0) {
          FACI_ID <- Parcels_filtered_df[temp, "FACILITYID"]
          WO_ID <- Parcels_filtered_df[temp, "workorder_id"]
          WO_Date <- Parcels_filtered_df[temp, "wo_initiatedate"]
          SMPID <- GSI [i,"SMP_ID"]
          SMPID_Vec <- rep(SMPID, length(temp))
          Buffer_Vec <-  rep(Buffer, length(temp))
          df <- data.frame(SMPID_Vec, FACI_ID, Buffer_Vec, WO_ID, WO_Date)
          output <- rbind(output, df ) 
        }
        
      output_50 <-output
        
      }
      
  # buffer 100 ft 
      
      Inters_Obj <- SMP_inters_100
      GSI <- as.data.frame(SMP)
      Buffer <- 100
      output <- NULL
      df <- NULL
      for(i in 1:length(Inters_Obj)) {
      temp <- Inters_Obj[[i]]
        if (length(temp) > 0) {
          FACI_ID <- Parcels_filtered_df[temp, "FACILITYID"]
          WO_ID <- Parcels_filtered_df[temp, "workorder_id"]
          WO_Date <- Parcels_filtered_df[temp, "wo_initiatedate"]
          SMPID <- GSI [i,"SMP_ID"]
          SMPID_Vec <- rep(SMPID, length(temp))
          Buffer_Vec <-  rep(Buffer, length(temp))
          df <- data.frame(SMPID_Vec, FACI_ID, Buffer_Vec, WO_ID, WO_Date)
          output <- rbind(output, df ) 
          
        }
      
        output_100 <-output
      
      }
    
## Section 4: Final processing of the result data frame nad writing to DB 
  #stick them together, name them, add the system id
###Taylor says: Filter to complete cases (ie, no NAs or gaps in data) and write to DB
      
      Result <- bind_rows(output_25, output_50, output_100) 
      if (length(Result) > 0) {
        
        names(Result) <- c("smp_id", "wic_facility_id","buffer_ft", "workorder_id","wo_initiatedate")
        
      }
      
      Result <- Result %>% na.omit
      Result['system_id'] <- gsub('-\\d+$','',Result$smp_id )

## section 5: categorizing the SMPs to pre, during, or post construction
      wic_conphase <- data.frame(wic_uid = 1:4, phase = c("pre-construction", "during construction", "post-construction", "unknown"))
      external.cipit_project <- dbGetQuery(MARSDB_con, "SELECT * FROM external.cipit_project")
      external.smpbdv <- dbGetQuery(MARSDB_con, "SELECT * FROM  external.smpbdv")
      worknumber <- inner_join(Result,external.smpbdv, by = "smp_id" )  %>% select( smp_id, wic_facility_id,buffer_ft, workorder_id,wo_initiatedate, worknumber)
      smp_milestones <- inner_join(external.cipit_project, worknumber, by = c("work_number" = "worknumber"  ))  %>% select (smp_id, wic_facility_id,buffer_ft, workorder_id,wo_initiatedate, construction_start_date, pc_ntp_date, construction_complete_date, contract_closed_date) %>% unique()
      
  #setting the lookup_id's default in smpmilestone to 4
    
      smp_milestones['phase_lookup_uid'] <- "unknown"
      for(i in 1:nrow(smp_milestones)) {
        if (!is.na(smp_milestones[i, "construction_start_date"]) && !is.na(smp_milestones[i, "construction_complete_date"]) ) {
            if (smp_milestones[i, "wo_initiatedate"] >= smp_milestones[i, "construction_start_date"] && smp_milestones[i, "wo_initiatedate"] <= smp_milestones[i, "construction_complete_date"]  ) {
              smp_milestones[i, "phase_lookup_uid"] <- "During-construction"
            } else if (smp_milestones[i, "wo_initiatedate"] < smp_milestones[i, "construction_start_date"]) {
              smp_milestones[i, "phase_lookup_uid"] <- "Pre-construction"
            } else {
              smp_milestones[i, "phase_lookup_uid"] <- "Post-construction"
          }
        } else if (!is.na(smp_milestones[i, "pc_ntp_date"]) && !is.na(smp_milestones[i, "construction_complete_date"] )) {
            if (smp_milestones[i, "wo_initiatedate"] >= smp_milestones[i, "pc_ntp_date"] && smp_milestones[i, "wo_initiatedate"] <= smp_milestones[i, "construction_complete_date"]  ) {
              smp_milestones[i, "phase_lookup_uid"] <- "During-construction"
            } else if (smp_milestones[i, "wo_initiatedate"] < smp_milestones[i, "pc_ntp_date"]) {
              smp_milestones[i, "phase_lookup_uid"] <- "Pre-construction"
            } else {
              smp_milestones[i, "phase_lookup_uid"] <- "Post-construction"
          }
          
        } else if (!is.na(smp_milestones[i, "construction_start_date"]) && !is.na(smp_milestones[i, "contract_closed_date"])) {
            if (smp_milestones[i, "wo_initiatedate"] >= smp_milestones[i, "construction_start_date"] && smp_milestones[i, "wo_initiatedate"] <= smp_milestones[i, "contract_closed_date"]  ) {
              smp_milestones[i, "phase_lookup_uid"] <- "During-construction"
            } else if (smp_milestones[i, "wo_initiatedate"] < smp_milestones[i, "construction_start_date"]) {
              smp_milestones[i, "phase_lookup_uid"] <- "Pre-construction"
            } else {
              smp_milestones[i, "phase_lookup_uid"] <- "Post-construction"
          }
        } else if (!is.na(smp_milestones[i, "pc_ntp_date"]) && !is.na(smp_milestones[i, "contract_closed_date"])) {
            if (smp_milestones[i, "wo_initiatedate"] >= smp_milestones[i, "pc_ntp_date"] && smp_milestones[i, "wo_initiatedate"] <= smp_milestones[i, "contract_closed_date"]  ) {
              smp_milestones[i, "phase_lookup_uid"] <- "During-construction"
            } else if (smp_milestones[i, "wo_initiatedate"] < smp_milestones[i, "pc_ntp_date"]) {
              smp_milestones[i, "phase_lookup_uid"] <- "Pre-construction"
            } else {
              smp_milestones[i, "phase_lookup_uid"] <- "Post-construction"
            }
          
        } else { 
              smp_milestones[i, "phase_lookup_uid"] <- "unknown"
          }
      }
      
      fieldwork.wic_smps <- smp_milestones %>% select(workorder_id,smp_id, wic_facility_id, buffer_ft, phase_lookup_uid)
      fieldwork.wic_smps['system_id'] <- gsub('-\\d+$','',fieldwork.wic_smps$smp_id ) 
    
      if (nrow(fieldwork.wic_smps) > 0 & params$write == TRUE){
        dbWriteTable (con, SQL("fieldwork.wic_smps"),fieldwork.wic_smps,append= TRUE, row.names = FALSE)
      }
      

   
```
Public SMPs were intersected with parcels associated with new/changed WIC work orders within 25, 50, and 100 ft of distance from them. This resulted in `r nrow( smp_milestones %>% filter(phase_lookup_uid=="Pre-construction"))` SMP attachment in Pre-construction phase, `r nrow( smp_milestones %>% filter(phase_lookup_uid=="During-construction"))` SMP attachment during-construction phase, `r nrow( smp_milestones %>% filter(phase_lookup_uid=="Post-construction"))` SMP attachment in Post-construction phase, and `r nrow( smp_milestones %>% filter(phase_lookup_uid=="unknown"))` SMP attachment with unknown construction phase.


```{r section 8- trimming for the showing the table in kable, include = FALSE, eval= nrow(smp_milestones)>0}

      smp_milestones <- smp_milestones %>% select(workorder_id, smp_id,  construction_phase = phase_lookup_uid , buffer_ft)

```

```{r section 9- displaying summary table of SMP association, include=FALSE, echo=FALSE, results='asis',eval= nrow(smp_milestones)>0}

      
      kable(smp_milestones, caption = "New WIC_SMP association at 25, 50, and 100 ft buffer distance")

```


```{r section 10- DB disconnect, include=FALSE}

      dbDisconnect(MARSDB_con)
      dbDisconnect(cityworksDB_con)
      dbDisconnect(GISDB_con)

```